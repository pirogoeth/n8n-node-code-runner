import * as child_process from 'child_process';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as process from 'process';
import { createHash } from 'crypto';

import {
  IExecuteFunctions,
  INodeExecutionData,
  RequestHelperFunctions,
} from 'n8n-workflow';

import * as yauzl from 'yauzl-promise';

import { BaseRuntime, CodeType } from '../base';

function getBunDownloadLink(os: string, arch: string): string {
  return `https://github.com/oven-sh/bun/releases/latest/download/bun-${os}-${arch}.zip`;
}

function getBunChecksumsLink(): string {
  return 'https://github.com/oven-sh/bun/releases/latest/download/SHASUMS256.txt';
}

class ChildOutput {
	// Only one of success or error should be set
	success?: {
		result: INodeExecutionData[];
	};
	error?: {
		exitCode: number;
		signal?: string;
		output: string;
	};

	static success(args: ChildOutput["success"]): ChildOutput {
		let out = new ChildOutput();
		out.success = args;

		return out;
	}

	static error(args: ChildOutput["error"]): ChildOutput {
		let out = new ChildOutput();
		out.error = args;

		return out;
	}

	isOk(): boolean {
		return this.success !== undefined;
	}

	isErr(): boolean {
		return this.error !== undefined;
	}

	unwrap(): ChildOutput["success"] {
		if (!this.isOk()) {
			throw new Error('tried to unwrap on error');
		}
		return this.success!;
	}

	unwrapErr(): ChildOutput["error"] {
		if (!this.isErr()) {
			throw new Error('tried to unwrapErr on ok');
		}
		return this.error!;
	}
}

export class BunRuntime implements BaseRuntime {
  getRuntimeDir(): string {
    const tmpDir = process.env.CODERUNNER_DIR || process.env.TMPDIR || '/tmp/coderunner-n8n';
    return path.join(tmpDir, 'bun');
  }

  getBunExecutablePath(): string {
    return path.join(this.getRuntimeDir(), 'bun');
  }

  getRuntimeCacheDir(): string {
    return path.join(this.getRuntimeDir(), 'cache');
  }

  async getRuntimeCodeCache(nodeId: string, code: string, codeType: CodeType): Promise<string> {
    const cacheDir = this.getRuntimeCacheDir();
    const shimPath = await this.writeShim();

    const nodeCacheDir = path.join(cacheDir, nodeId);
    const codeSha = createHash('sha256').update(code).digest('hex').slice(0, 12);
    const codePath = path.join(nodeCacheDir, codeSha, 'code');

    try {
      await fs.access(codePath);
    } catch (err) {
      await fs.mkdir(path.dirname(codePath), { recursive: true });
      await fs.writeFile(codePath, code);
      await this.writeBunfig(path.dirname(codePath), nodeCacheDir, shimPath);
    }

    return codePath;
  }

  getShimCachePath(): string {
    return path.join(this.getRuntimeDir(), 'shim');
  }

  getShimScriptPath(): string {
    return path.join(this.getShimCachePath(), 'shim.js');
  }

  async writeShim(): Promise<string> {
    const shimPath = this.getShimCachePath();
    const bunShimFiles = path.join(__dirname, 'shim', '*');
    try {
      await fs.access(shimPath);
      await fs.access(this.getShimScriptPath());
    } catch (err) {
      await fs.mkdir(shimPath, { recursive: true });
      for await (const shimFile of fs.glob(bunShimFiles)) {
        const stat = await fs.lstat(shimFile);
        if (stat.isDirectory() || stat.isSymbolicLink()) {
          await fs.cp(shimFile, path.join(shimPath, path.basename(shimFile)), {
            dereference: true,
            recursive: true,
          });
        } else if (stat.isFile()) {
          await fs.copyFile(
            shimFile,
            path.join(shimPath, path.basename(shimFile)),
          );
        }
      }
    }

    return shimPath;
  }

  async writeBunfig(codeDir: string, cacheDir: string, shimPath: string) {
    const bunfigPath = path.join(codeDir, 'bunfig.toml');
    try {
      await fs.access(bunfigPath);
    } catch (err) {
      await fs.writeFile(bunfigPath, `# This file is generated by n8n-nodes-code-runner
[install.cache]
dir = '${path.join(cacheDir, 'packages')}'
disable = false
`);
    }
  }

  async getRuntime(): Promise<path.ParsedPath|null> {
    const runtimeDir = this.getRuntimeDir();

    try {
      await fs.access(runtimeDir);
    } catch (err) {
      await fs.mkdir(runtimeDir, { recursive: true });
    }

    const bunBinPath = this.getBunExecutablePath();
    try {
      await fs.access(bunBinPath);
      return path.parse(bunBinPath);
    } catch (err) {
      return null;
    }
  }

  async fetchRuntime(requester: RequestHelperFunctions["httpRequest"]): Promise<path.ParsedPath> {
    let os;
    switch (process.platform) {
      case 'linux':
      case 'darwin':
        os = process.platform;
        break;
      case 'win32':
        os = 'windows';
      default:
        throw new Error(`Unsupported OS: ${process.platform}`);
    }
    let arch;
    switch (process.arch) {
      case 'x64':
        arch = 'x64';
        break;
      case 'arm64':
        arch = 'aarch64';
        break;
      default:
        throw new Error(`Unsupported architecture: ${process.arch}`);
    }

    const runtimeDir = this.getRuntimeDir();
    const downloadLink = getBunDownloadLink(os, arch);
    const checksumsLink = getBunChecksumsLink();
    const archiveFileName = `bun-${os}-${arch}.zip`;
    const archivePath = path.join(runtimeDir, archiveFileName);

    // Download Bun runtime archive
    let archiveResponse = await requester({
      url: downloadLink,
      encoding: 'arraybuffer',
    });
    await fs.writeFile(archivePath, archiveResponse, {
      encoding: 'binary',
    });

    // Download checksums file
    let checksumsResponse = await requester({
      url: checksumsLink,
    });
    for (const line of checksumsResponse.split('\n')) {
      if (line.endsWith(archiveFileName)) {
        const [expectedChecksum, _] = line.split(' ');
        const hash = createHash('sha256');
        hash.update(await fs.readFile(archivePath));
        const archiveChecksum = hash.digest('hex');
        if (archiveChecksum !== expectedChecksum) {
          await fs.rm(archivePath);
          throw new Error(`Checksum mismatch: ${expectedChecksum} != ${archiveChecksum}`);
        }
      }
    }

    const bunBinPath = this.getBunExecutablePath();

    // Extract archive
    const zip = await yauzl.open(archivePath);
    try {
      for await (const item of zip) {
        if (item.filename.endsWith("bun")) {
          await fs.writeFile(bunBinPath, await item.openReadStream());
          await fs.chmod(bunBinPath, 0o755);
        }
      }
    } finally {
      await zip.close();
    }

    return path.parse(bunBinPath);
  }

  async execute(that: IExecuteFunctions, codeType: CodeType, code: string, inputs: INodeExecutionData[]): Promise<INodeExecutionData[][]> {
    let bunRuntime = await this.getRuntime();
    if (!bunRuntime) {
      bunRuntime = await this.fetchRuntime(that.helpers.httpRequest);
    }

    // Create node code cache and prep dependencies
    const nodeId = that.getNode().id;
    const codePath = await this.getRuntimeCodeCache(nodeId, code, codeType);

    const bunBinPath = this.getBunExecutablePath();
    const childLogOutputFilePath = path.join(path.dirname(codePath), `output-${that.getExecutionId()}.log`);
    const childLogOutputFile = await fs.open(childLogOutputFilePath, 'wx+');
    const childLogOutput = childLogOutputFile.createWriteStream();

    // Execute the cached code w/ shim
    const runner = child_process.spawn(
      bunBinPath,
      [
        'run',
        `--config=${path.dirname(codePath)}/bunfig.toml`,
        '--install=auto',
        '--prefer-offline',
        this.getShimScriptPath(),
      ],
      {
        cwd: path.dirname(codePath),
        serialization: 'json',
        env: {
          CODE_DIR: path.dirname(codePath),
          BUN_CONFIG: path.join(path.dirname(codePath), 'bunfig.toml'),
        },
        stdio: ['pipe', childLogOutput, childLogOutput, 'pipe'],
      }
    )

    await runner.stdin!.write(JSON.stringify(inputs)+'\n');
    runner.stdin!.end();

    const childResult: Buffer = await new Promise((resolve, reject) => {
      const chunks: Buffer[] = [];
      runner.stdio[3]!.on('data', (chunk) => {
        console.debug('received some data from child result pipe');
        chunks.push(Buffer.from(chunk));
      });
      runner.stdio[3]!.on('end', () => {
        console.debug('child process closed result pipe');
        resolve(Buffer.concat(chunks));
      });
      runner.stdio[3]!.on('error', reject);
    });

    const childExit: ChildOutput = await new Promise((resolve, reject) => {
      runner.on('exit', async (exitCode, signal) => {
        if (exitCode === 0) {
					return resolve(ChildOutput.success({
						result: JSON.parse(childResult.toString())
					}));
        }

        const outputLogs = await fs.readFile(childLogOutputFilePath);
        console.error(`child process exited with code ${code} and signal ${signal}`);
        console.error(outputLogs.toString());
				return reject(ChildOutput.error({
					exitCode: exitCode ?? -1,
					signal: signal ?? undefined,
					output: outputLogs.toString(),
				}));
      });
      runner.on('error', reject);
    });
    await childLogOutput.close();
    await childLogOutputFile.close();

		if (childExit.isErr()) {
			let err = childExit.unwrapErr();
			throw new Error(`Child process exited with code ${err?.exitCode} and signal ${err?.signal}`);
		}
    console.log('results:', childExit);

    return [childExit.unwrap()?.result ?? []];
  }
}
